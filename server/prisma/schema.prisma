
// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id                     String                  @id @default(uuid()) @db.Uuid
  username               String                  @unique
  name                   String
  email                  String                  @unique
  passwordHash           String?
  college                String?
  bio                    String?
  headline               String?
  timezone               String?                 @db.VarChar(64)
  profileImg             String?
  heroImage              String?
  skillcoins             Int                      @default(0)
  role                   Role                     @default(USER)
  availability           UserAvailability         @default(ONLINE)
  statusMessage          String?                  @db.VarChar(140)
  googleId               String?                  @unique
  emailVerified          Boolean                  @default(false)
  profileCompleted       Boolean                  @default(false)
  lastActiveAt           DateTime?
  searchPreferences      Json?
  onboardingStep         Int                      @default(0)
  subscriptionTier       SubscriptionTier         @default(FREE)
  socialLinks            SocialLink[]
  skillsTeaching         Skill[]                  @relation("TeachingSkills")
  skillsLearning         Skill[]                  @relation("LearningSkills")
  skillRequestsSent      SkillRequest[]           @relation("RequestsSent")
  skillRequestsReceived  SkillRequest[]           @relation("RequestsReceived")
  mentorshipsMentor      Mentorship[]             @relation("MentorMentorships")
  mentorshipsLearner     Mentorship[]             @relation("LearnerMentorships")
  projectsPosted         Project[]                @relation("PostedProjects")
  projectApplications    ProjectApplication[]
  projectMessages        ProjectMessage[]
  followers              Follow[]                 @relation("Following")
  following              Follow[]                 @relation("Followers")
  subscriptions          Subscription[]           @relation("Subscriber")
  subscribers            Subscription[]           @relation("SubscribedTo")
  reviewsGiven           Review[]                 @relation("ReviewsGiven")
  reviewsReceived        Review[]                 @relation("ReviewsReceived")
  sessions               UserSession[]
  authTokens             AuthToken[]
  matches                SkillMatch[]             @relation("MatchesAsUser")
  matchedBy              SkillMatch[]             @relation("MatchesAsMatch")
  messages               Message[]
  threads                ThreadParticipant[]
  notifications          Notification[]
  notificationPreference NotificationPreference?
  transactions           Transaction[]
  forumPosts             ForumPost[]
  forumComments          ForumComment[]
  badges                 Badge[]
  verifiedSkills         VerifiedSkill[]
  walletEntries          WalletEntry[]
  createdAt              DateTime                 @default(now())
  updatedAt              DateTime                 @updatedAt

  @@index([email])
  @@index([college])
  @@index([lastActiveAt])
}

model UserSession {
  id           String   @id @default(uuid()) @db.Uuid
  userId       String   @db.Uuid
  refreshToken String   @db.VarChar(512)
  userAgent    String?  @db.VarChar(255)
  ipAddress    String?  @db.VarChar(64)
  expiresAt    DateTime
  createdAt    DateTime @default(now())
  revokedAt    DateTime?
  metadata     Json?
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([expiresAt])
  @@unique([userId, refreshToken])
}

model AuthToken {
  id         String         @id @default(uuid()) @db.Uuid
  userId     String         @db.Uuid
  type       AuthTokenType
  tokenHash  String         @db.VarChar(512)
  expiresAt  DateTime
  consumedAt DateTime?
  metadata   Json?
  createdAt  DateTime       @default(now())
  user       User           @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, type])
  @@unique([type, tokenHash])
}

model Skill {
  id             String             @id @default(uuid()) @db.Uuid
  name           String
  category       String
  level          SkillLevel
  description    String             @db.Text
  sessionMode    SessionMode        @default(ONLINE)
  visibility     SkillVisibility    @default(PUBLIC)
  location       String?            @db.VarChar(120)
  deliveryModes  Json?
  featured       Boolean            @default(false)
  searchVector   Unsupported("tsvector")?
  tags           Tag[]
  teacher        User               @relation("TeachingSkills", fields: [teacherId], references: [id], onDelete: Cascade)
  teacherId      String             @db.Uuid
  learners       User[]             @relation("LearningSkills")
  skillRequests  SkillRequest[]
  mentorships    Mentorship[]
  requiredFor    Project[]          @relation("RequiredSkills")
  createdAt      DateTime           @default(now())
  updatedAt      DateTime           @updatedAt

  @@index([category])
  @@index([teacherId])
  @@index([featured])
}

model SkillRequest {
  id            String         @id @default(uuid()) @db.Uuid
  requesterId   String         @db.Uuid
  teacherId     String         @db.Uuid
  skillId       String         @db.Uuid
  status        RequestStatus  @default(PENDING)
  message       String?        @db.Text
  preferredSlot Json?
  createdAt     DateTime       @default(now())
  updatedAt     DateTime       @updatedAt
  requester     User           @relation("RequestsSent", fields: [requesterId], references: [id], onDelete: Cascade)
  teacher       User           @relation("RequestsReceived", fields: [teacherId], references: [id], onDelete: Cascade)
  skill         Skill          @relation(fields: [skillId], references: [id], onDelete: Cascade)

  @@index([requesterId])
  @@index([teacherId])
  @@index([skillId])
  @@index([status])
}

model Mentorship {
  id            String            @id @default(uuid()) @db.Uuid
  mentorId      String            @db.Uuid
  learnerId     String            @db.Uuid
  skillId       String            @db.Uuid
  mentorshipType MentorshipType   @default(ONE_TO_ONE)
  status        MentorshipStatus  @default(SCHEDULED)
  startDate     DateTime
  endDate       DateTime?
  meetingLink   String?           @db.VarChar(255)
  notes         String?           @db.Text
  metadata      Json?
  createdAt     DateTime          @default(now())
  updatedAt     DateTime          @updatedAt
  mentor        User              @relation("MentorMentorships", fields: [mentorId], references: [id], onDelete: Cascade)
  learner       User              @relation("LearnerMentorships", fields: [learnerId], references: [id], onDelete: Cascade)
  skill         Skill             @relation(fields: [skillId], references: [id], onDelete: Cascade)
  sessions      MentorshipSession[]

  @@index([mentorId])
  @@index([learnerId])
  @@index([skillId])
  @@index([status])
}

model MentorshipSession {
  id            String    @id @default(uuid()) @db.Uuid
  mentorshipId  String    @db.Uuid
  scheduledFor  DateTime
  durationMins  Int
  status        MentorshipSessionStatus @default(SCHEDULED)
  meetingUrl    String?   @db.VarChar(255)
  notes         String?   @db.Text
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt
  mentorship    Mentorship @relation(fields: [mentorshipId], references: [id], onDelete: Cascade)

  @@index([mentorshipId])
  @@index([scheduledFor])
}

model Project {
  id             String             @id @default(uuid()) @db.Uuid
  title          String
  description    String             @db.Text
  posterId       String             @db.Uuid
  budgetMin      Float
  budgetMax      Float
  deadline       DateTime
  status         ProjectStatus      @default(OPEN)
  location       String?            @db.VarChar(120)
  remoteFriendly Boolean            @default(true)
  metadata       Json?
  searchVector   Unsupported("tsvector")?
  createdAt      DateTime           @default(now())
  updatedAt      DateTime           @updatedAt
  poster         User               @relation("PostedProjects", fields: [posterId], references: [id], onDelete: Cascade)
  applications   ProjectApplication[]
  skillsRequired Skill[]            @relation("RequiredSkills")
  milestones     ProjectMilestone[]
  discussions    ProjectMessage[]

  @@index([posterId])
  @@index([status])
  @@index([remoteFriendly])
}

model ProjectMilestone {
  id          String        @id @default(uuid()) @db.Uuid
  projectId   String        @db.Uuid
  title       String
  description String?       @db.Text
  dueDate     DateTime?
  status      MilestoneStatus @default(PENDING)
  createdAt   DateTime       @default(now())
  updatedAt   DateTime       @updatedAt
  project     Project        @relation(fields: [projectId], references: [id], onDelete: Cascade)

  @@index([projectId])
}

model ProjectMessage {
  id          String        @id @default(uuid()) @db.Uuid
  projectId   String        @db.Uuid
  senderId    String        @db.Uuid
  content     String        @db.Text
  attachments Json?
  createdAt   DateTime      @default(now())
  project     Project       @relation(fields: [projectId], references: [id], onDelete: Cascade)
  sender      User          @relation(fields: [senderId], references: [id], onDelete: Cascade)

  @@index([projectId])
  @@index([senderId])
}

model ProjectApplication {
  id           String             @id @default(uuid()) @db.Uuid
  projectId    String             @db.Uuid
  applicantId  String             @db.Uuid
  proposal     String             @db.Text
  bidAmount    Float
  status       ApplicationStatus  @default(PENDING)
  attachments  Json?
  createdAt    DateTime           @default(now())
  updatedAt    DateTime           @updatedAt
  project      Project            @relation(fields: [projectId], references: [id], onDelete: Cascade)
  applicant    User               @relation(fields: [applicantId], references: [id], onDelete: Cascade)

  @@index([projectId])
  @@index([applicantId])
  @@index([status])
}

model Follow {
  followerId  String   @db.Uuid
  followingId String   @db.Uuid
  createdAt   DateTime @default(now())
  follower    User     @relation("Following", fields: [followerId], references: [id], onDelete: Cascade)
  following   User     @relation("Followers", fields: [followingId], references: [id], onDelete: Cascade)

  @@id([followerId, followingId])
  @@index([followerId])
  @@index([followingId])
}

model Subscription {
  id              String             @id @default(uuid()) @db.Uuid
  subscriberId    String             @db.Uuid
  subscribedToId  String             @db.Uuid
  tier            SubscriptionTier   @default(PREMIUM)
  status          SubscriptionStatus @default(ACTIVE)
  startedAt       DateTime           @default(now())
  renewedAt       DateTime?
  expiresAt       DateTime?
  metadata        Json?
  subscriber      User               @relation("Subscriber", fields: [subscriberId], references: [id], onDelete: Cascade)
  subscribedTo    User               @relation("SubscribedTo", fields: [subscribedToId], references: [id], onDelete: Cascade)

  @@unique([subscriberId, subscribedToId])
  @@index([status])
}

model Review {
  id          String   @id @default(uuid()) @db.Uuid
  reviewerId  String   @db.Uuid
  reviewedId  String   @db.Uuid
  rating      Int      @db.SmallInt
  comment     String   @db.Text
  tags        String[]
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  reviewer    User     @relation("ReviewsGiven", fields: [reviewerId], references: [id], onDelete: Cascade)
  reviewed    User     @relation("ReviewsReceived", fields: [reviewedId], references: [id], onDelete: Cascade)

  @@index([reviewerId])
  @@index([reviewedId])
}

model MessageThread {
  id          String               @id @default(uuid()) @db.Uuid
  createdAt   DateTime             @default(now())
  updatedAt   DateTime             @updatedAt
  lastMessage DateTime?
  metadata    Json?
  messages    Message[]
  participants ThreadParticipant[]
}

model ThreadParticipant {
  id        String        @id @default(uuid()) @db.Uuid
  threadId  String        @db.Uuid
  userId    String        @db.Uuid
  role      ThreadRole    @default(MEMBER)
  joinedAt  DateTime      @default(now())
  muted     Boolean       @default(false)
  thread    MessageThread @relation(fields: [threadId], references: [id], onDelete: Cascade)
  user      User          @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([threadId, userId])
  @@index([userId])
}

model Message {
  id          String        @id @default(uuid()) @db.Uuid
  threadId    String        @db.Uuid
  senderId    String        @db.Uuid
  content     String        @db.Text
  attachments Json?
  readBy      String[]
  createdAt   DateTime      @default(now())
  updatedAt   DateTime      @updatedAt
  thread      MessageThread @relation(fields: [threadId], references: [id], onDelete: Cascade)
  sender      User          @relation(fields: [senderId], references: [id], onDelete: Cascade)

  @@index([threadId])
  @@index([senderId])
}

model Notification {
  id         String               @id @default(uuid()) @db.Uuid
  userId     String               @db.Uuid
  type       NotificationType
  title      String               @db.VarChar(160)
  content    String               @db.Text
  channel    NotificationChannel  @default(IN_APP)
  isRead     Boolean              @default(false)
  metadata   Json?
  createdAt  DateTime             @default(now())
  readAt     DateTime?
  user       User                 @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, isRead])
  @@index([createdAt])
}

model NotificationPreference {
  id             String              @id @default(uuid()) @db.Uuid
  userId         String              @db.Uuid
  inApp          Boolean             @default(true)
  email          Boolean             @default(true)
  push           Boolean             @default(false)
  digestFrequency DigestFrequency    @default(DAILY)
  quietHours     Json?
  createdAt      DateTime            @default(now())
  updatedAt      DateTime            @updatedAt
  user           User                @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId])
}

model Transaction {
  id          String            @id @default(uuid()) @db.Uuid
  userId      String            @db.Uuid
  amount      Int
  type        TransactionType
  description String
  referenceId String?           @db.VarChar(120)
  metadata    Json?
  createdAt   DateTime          @default(now())
  user        User              @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([createdAt])
}

model WalletEntry {
  id          String        @id @default(uuid()) @db.Uuid
  userId      String        @db.Uuid
  change      Int
  balance     Int
  reason      WalletReason
  metadata    Json?
  createdAt   DateTime      @default(now())
  user        User          @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([createdAt])
}

model ForumPost {
  id          String         @id @default(uuid()) @db.Uuid
  authorId    String         @db.Uuid
  title       String
  content     String         @db.Text
  category    ForumCategory
  tags        String[]
  upvotes     Int            @default(0)
  downvotes   Int            @default(0)
  metadata    Json?
  createdAt   DateTime       @default(now())
  updatedAt   DateTime       @updatedAt
  author      User           @relation(fields: [authorId], references: [id], onDelete: Cascade)
  comments    ForumComment[]

  @@index([authorId])
  @@index([category])
  @@index([createdAt])
}

model ForumComment {
  id         String        @id @default(uuid()) @db.Uuid
  postId     String        @db.Uuid
  authorId   String        @db.Uuid
  content    String        @db.Text
  upvotes    Int           @default(0)
  downvotes  Int           @default(0)
  createdAt  DateTime      @default(now())
  updatedAt  DateTime      @updatedAt
  post       ForumPost     @relation(fields: [postId], references: [id], onDelete: Cascade)
  author     User          @relation(fields: [authorId], references: [id], onDelete: Cascade)

  @@index([postId])
  @@index([authorId])
}

model Tag {
  id         String   @id @default(uuid()) @db.Uuid
  name       String   @unique
  kind       TagKind  @default(SKILL)
  createdAt  DateTime @default(now())
  skills     Skill[]

  @@index([name])
}

model SocialLink {
  id        String    @id @default(uuid()) @db.Uuid
  userId    String    @db.Uuid
  platform  Platform
  url       String
  createdAt DateTime  @default(now())
  user      User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
}

model Badge {
  id         String    @id @default(uuid()) @db.Uuid
  userId     String    @db.Uuid
  type       BadgeType
  awardedAt  DateTime  @default(now())
  metadata   Json?
  user       User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
}

model VerifiedSkill {
  id          String    @id @default(uuid()) @db.Uuid
  userId      String    @db.Uuid
  skillName   String
  authority   String?
  verifiedAt  DateTime  @default(now())
  user        User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
}

model SkillMatch {
  id           String   @id @default(uuid()) @db.Uuid
  userId       String   @db.Uuid
  matchUserId  String   @db.Uuid
  score        Float
  reasons      String[]
  metadata     Json?
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
  user         User     @relation("MatchesAsUser", fields: [userId], references: [id], onDelete: Cascade)
  matchUser    User     @relation("MatchesAsMatch", fields: [matchUserId], references: [id], onDelete: Cascade)

  @@unique([userId, matchUserId])
  @@index([score])
}

enum Role {
  USER
  MENTOR
  ADMIN
}

enum UserAvailability {
  ONLINE
  BUSY
  LEARNING
  OFFLINE
}

enum SkillLevel {
  BEGINNER
  INTERMEDIATE
  EXPERT
}

enum SkillVisibility {
  PUBLIC
  FOLLOWERS
  SUBSCRIBERS
  PRIVATE
}

enum SessionMode {
  ONLINE
  IN_PERSON
  HYBRID
}

enum RequestStatus {
  PENDING
  ACCEPTED
  REJECTED
  CANCELLED
}

enum MentorshipStatus {
  SCHEDULED
  IN_PROGRESS
  COMPLETED
  CANCELLED
}

enum MentorshipSessionStatus {
  SCHEDULED
  COMPLETED
  CANCELLED
  NO_SHOW
}

enum MentorshipType {
  ONE_TO_ONE
  GROUP
  BOOTCAMP
}

enum ProjectStatus {
  OPEN
  IN_PROGRESS
  COMPLETED
  CLOSED
  CANCELLED
}

enum MilestoneStatus {
  PENDING
  ACTIVE
  SUBMITTED
  APPROVED
  REJECTED
}

enum ApplicationStatus {
  PENDING
  ACCEPTED
  REJECTED
  WITHDRAWN
}

enum NotificationType {
  NEW_FOLLOWER
  SESSION_REQUEST
  SESSION_RESPONSE
  PROJECT_UPDATE
  NEW_REVIEW
  SKILL_MATCH
  CREDIT_RECEIVED
  MILESTONE_DUE
  PROMOTION
}

enum NotificationChannel {
  IN_APP
  EMAIL
  PUSH
}

enum TransactionType {
  EARNED
  SPENT
  REFUNDED
  BONUS
  WITHDRAWAL
  DEPOSIT
}

enum WalletReason {
  SESSION_PAYOUT
  SESSION_SPEND
  PROJECT_PAYOUT
  PROJECT_DEPOSIT
  BONUS
  REFUND
  ADJUSTMENT
}

enum ForumCategory {
  TECHNICAL
  CREATIVE
  SOFT_SKILLS
  LANGUAGES
  FREELANCE
  GENERAL
  STARTUPS
}

enum Platform {
  GITHUB
  LINKEDIN
  TWITTER
  PORTFOLIO
  OTHER
  BEHANCE
  DRIBBBLE
}

enum BadgeType {
  TOP_MENTOR
  RISING_TALENT
  RELIABLE_COLLABORATOR
  SKILL_MASTER
  COMMUNITY_LEADER
  INNOVATOR
}

enum SubscriptionTier {
  FREE
  PREMIUM
  VERIFIED
  ELITE
}

enum SubscriptionStatus {
  ACTIVE
  PAST_DUE
  CANCELLED
  PAUSED
}

enum AuthTokenType {
  EMAIL_VERIFY
  PASSWORD_RESET
  MAGIC_LOGIN
}

enum DigestFrequency {
  DAILY
  WEEKLY
  MONTHLY
}

enum ThreadRole {
  MEMBER
  OWNER
  MODERATOR
}

enum TagKind {
  SKILL
  PROJECT
  FORUM
}

